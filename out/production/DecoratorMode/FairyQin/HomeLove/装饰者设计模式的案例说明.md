## 5.3 装饰者模式

### 5.3.1 概述

我们先来看一个快餐店的例子。

快餐店有炒面、炒饭这些快餐，可以额外附加鸡蛋、火腿、培根这些配菜，当然加配菜需要额外加钱，每个配菜的价钱通常不太一样，那么计算总价就会显得比较麻烦。

![装饰者类图](https://cdn.staticaly.com/gh/GhostQinMo/ImageBed@master/DesignModeAll/%E8%A3%85%E9%A5%B0%E8%80%85%E7%B1%BB%E5%9B%BE.png)

使用继承的方式存在的问题：

* 扩展性不好

  如果要再加一种配料（火腿肠），我们就会发现需要给FriedRice和FriedNoodles分别定义一个子类。如果要新增一个快餐品类（炒河粉）的话，就需要定义更多的子类。

* 产生过多的子类

**定义：**<mark>指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式。

### 5.3.2 结构

装饰（Decorator）模式中的角色：

* 抽象构件（Component）角色 ：定义一个抽象接口（也可以是抽象类）以规范准备接收附加责任的对象。（上面的fastfood就是抽象构件）
* 具体构件（Concrete Component）角色 ：实现抽象构件，通过装饰角色为其添加一些职责。（friedRice和friedNoodles就是具体构件）
* 抽象装饰（Decorator）角色 ： <mark>继承或实现抽象构件</mark>，并包含具体构件的实例（即聚合了<mark>具体构件</mark>），可以通过其<mark>子类</mark>扩展具体构件的功能。
* 具体装饰（ConcreteDecorator）角色 ：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。

### 5.3.3 案例

我们使用装饰者模式对快餐店案例进行改进，体会装饰者模式的精髓。

类图如下：（图的聚合箭头画错了啊）

![装饰者模式](https://cdn.staticaly.com/gh/GhostQinMo/ImageBed@master/DesignModeAll/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F.png)